{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Vinnare eCommerce Project Documentation Overview Vinnare is an eCommerce API built using .NET, structured into multiple layers for maintainability and scalability. It follows a modular approach, separating concerns across different projects. Project Structure Api/ : Contains the API layer with controllers, DTOs, middleware, and extensions. Data/ : Manages the database context, entities, and migrations. Services/ : Implements business logic with service classes and interfaces. Shared/ : Contains shared configurations, DTOs, enums, and exceptions. ConsoleAppMigration/ : A console application for managing database migrations. docs/ : Documentation files for the project using MkDocs. .github/ : CI/CD workflows for automated builds and deployments. logs/ : Contains application logs. Program.cs Overview The Program.cs file serves as the entry point of the API, configuring essential components: Service Registration Controllers Swagger for API documentation Security settings (JWT, authentication, authorization) Database configuration using Entity Framework Core Logging configuration Middleware Configuration Custom middleware for authentication and error handling HTTPS redirection Authentication & Authorization enforcement API routing How to Run the Project To run the project, ensure you are in the root folder . Using Docker: docker build . -f ./Api/Dockerfile Running Locally: dotnet restore dotnet build dotnet Api/bin/Debug/net8.0/Api.dll Documentation Structure The documentation is managed using MkDocs, with sections covering: - Features ( features.md ) - Setup and Execution ( how_to_run.md ) - Code Structure ( code.md ) - CI/CD Processes ( ci_cd.md ) - Technical Issues and Troubleshooting ( technical_issues.md ) - Architecture Diagrams ( diagrams.md )","title":"Vinnare eCommerce Project Documentation"},{"location":"#vinnare-ecommerce-project-documentation","text":"","title":"Vinnare eCommerce Project Documentation"},{"location":"#overview","text":"Vinnare is an eCommerce API built using .NET, structured into multiple layers for maintainability and scalability. It follows a modular approach, separating concerns across different projects.","title":"Overview"},{"location":"#project-structure","text":"Api/ : Contains the API layer with controllers, DTOs, middleware, and extensions. Data/ : Manages the database context, entities, and migrations. Services/ : Implements business logic with service classes and interfaces. Shared/ : Contains shared configurations, DTOs, enums, and exceptions. ConsoleAppMigration/ : A console application for managing database migrations. docs/ : Documentation files for the project using MkDocs. .github/ : CI/CD workflows for automated builds and deployments. logs/ : Contains application logs.","title":"Project Structure"},{"location":"#programcs-overview","text":"The Program.cs file serves as the entry point of the API, configuring essential components: Service Registration Controllers Swagger for API documentation Security settings (JWT, authentication, authorization) Database configuration using Entity Framework Core Logging configuration Middleware Configuration Custom middleware for authentication and error handling HTTPS redirection Authentication & Authorization enforcement API routing","title":"Program.cs Overview"},{"location":"#how-to-run-the-project","text":"To run the project, ensure you are in the root folder .","title":"How to Run the Project"},{"location":"#using-docker","text":"docker build . -f ./Api/Dockerfile","title":"Using Docker:"},{"location":"#running-locally","text":"dotnet restore dotnet build dotnet Api/bin/Debug/net8.0/Api.dll","title":"Running Locally:"},{"location":"#documentation-structure","text":"The documentation is managed using MkDocs, with sections covering: - Features ( features.md ) - Setup and Execution ( how_to_run.md ) - Code Structure ( code.md ) - CI/CD Processes ( ci_cd.md ) - Technical Issues and Troubleshooting ( technical_issues.md ) - Architecture Diagrams ( diagrams.md )","title":"Documentation Structure"},{"location":"features/","text":"Features Overview Vinnare is a .NET 8-based eCommerce API providing core functionalities for managing an online marketplace. It includes user authentication, product management, shopping features, and administrative approval workflows. Core Features User Authentication & Authorization JWT-based authentication Role-based access control (Admin, Seller, Shopper) Secure password hashing with salt and pepper Product & Category Management Sellers can create and manage products Categories to organize products Admin approval required for products and categories to be listed Shopping Features Add products to cart Checkout process Wishlist functionality Reviews with comments and ratings Discounts through coupon codes Admin Job Management Approval workflow for products and categories Role management and access control Technology Stack Backend : .NET 8, Entity Framework Core Testing : Moq and xUnit Security : JWT authentication, password hashing with salt and pepper Integrations Initial Data Load : Fetches test data from FakeStore API for development and testing purposes. Future Enhancements Scalability improvements (caching, performance optimization) Additional third-party integrations (payment gateways, analytics) Enhanced admin dashboard for better control and monitoring","title":"Features"},{"location":"features/#features","text":"","title":"Features"},{"location":"features/#overview","text":"Vinnare is a .NET 8-based eCommerce API providing core functionalities for managing an online marketplace. It includes user authentication, product management, shopping features, and administrative approval workflows.","title":"Overview"},{"location":"features/#core-features","text":"User Authentication & Authorization JWT-based authentication Role-based access control (Admin, Seller, Shopper) Secure password hashing with salt and pepper Product & Category Management Sellers can create and manage products Categories to organize products Admin approval required for products and categories to be listed Shopping Features Add products to cart Checkout process Wishlist functionality Reviews with comments and ratings Discounts through coupon codes Admin Job Management Approval workflow for products and categories Role management and access control","title":"Core Features"},{"location":"features/#technology-stack","text":"Backend : .NET 8, Entity Framework Core Testing : Moq and xUnit Security : JWT authentication, password hashing with salt and pepper","title":"Technology Stack"},{"location":"features/#integrations","text":"Initial Data Load : Fetches test data from FakeStore API for development and testing purposes.","title":"Integrations"},{"location":"features/#future-enhancements","text":"Scalability improvements (caching, performance optimization) Additional third-party integrations (payment gateways, analytics) Enhanced admin dashboard for better control and monitoring","title":"Future Enhancements"},{"location":"technical_issues/","text":"","title":"Technical issues"},{"location":"code/ci_cd/","text":"CI/CD Pipelines Overview The CI/CD pipeline automates the process of building, testing, and deploying the application using GitHub Actions . It consists of two workflows: CI Workflow ( ci.yml ) : Triggers on pushes to the actions branch and pull requests to main . Builds a Docker image from the Api/Dockerfile . Runs tests (currently a placeholder for future implementation). Pushes the Docker image to AWS ECR, tagging it with the commit hash. Passes the image tag to the deployment pipeline. CD Workflow ( cd.yml ) : Called by the CI pipeline after a successful build and push. Runs on an EC2 instance via SSH. Pulls the latest Docker image from ECR. Stops and removes the previous container. Deploys the new image as a running container. Secrets and Security AWS credentials and repository details are stored as GitHub secrets. The EC2 server's SSH credentials are securely stored and accessed only during deployment. Reasoning Why GitHub Actions? Cloud Advantages : No need to manage CI/CD infrastructure. Seamless Secret Management : Integrates easily with GitHub Secrets. Simplicity & Integration : Works natively with GitHub repositories. Why Two Pipelines? Separation of Concerns : CI (build, test, push) and CD (deploy) are handled separately. Better Modularity : Allows independent improvements and debugging of CI/CD stages. Secrets and Security AWS credentials and repository details are stored as GitHub secrets. The EC2 server's SSH credentials are securely stored and accessed only during deployment. Future Improvements Implement automated testing in the CI pipeline. Add monitoring and alerting for deployment failures. Improve rollback strategies in case of failed deployments.","title":"CI/CD Pipelines"},{"location":"code/ci_cd/#cicd-pipelines","text":"","title":"CI/CD Pipelines"},{"location":"code/ci_cd/#overview","text":"The CI/CD pipeline automates the process of building, testing, and deploying the application using GitHub Actions . It consists of two workflows: CI Workflow ( ci.yml ) : Triggers on pushes to the actions branch and pull requests to main . Builds a Docker image from the Api/Dockerfile . Runs tests (currently a placeholder for future implementation). Pushes the Docker image to AWS ECR, tagging it with the commit hash. Passes the image tag to the deployment pipeline. CD Workflow ( cd.yml ) : Called by the CI pipeline after a successful build and push. Runs on an EC2 instance via SSH. Pulls the latest Docker image from ECR. Stops and removes the previous container. Deploys the new image as a running container.","title":"Overview"},{"location":"code/ci_cd/#secrets-and-security","text":"AWS credentials and repository details are stored as GitHub secrets. The EC2 server's SSH credentials are securely stored and accessed only during deployment.","title":"Secrets and Security"},{"location":"code/ci_cd/#reasoning","text":"","title":"Reasoning"},{"location":"code/ci_cd/#why-github-actions","text":"Cloud Advantages : No need to manage CI/CD infrastructure. Seamless Secret Management : Integrates easily with GitHub Secrets. Simplicity & Integration : Works natively with GitHub repositories.","title":"Why GitHub Actions?"},{"location":"code/ci_cd/#why-two-pipelines","text":"Separation of Concerns : CI (build, test, push) and CD (deploy) are handled separately. Better Modularity : Allows independent improvements and debugging of CI/CD stages.","title":"Why Two Pipelines?"},{"location":"code/ci_cd/#secrets-and-security_1","text":"AWS credentials and repository details are stored as GitHub secrets. The EC2 server's SSH credentials are securely stored and accessed only during deployment.","title":"Secrets and Security"},{"location":"code/ci_cd/#future-improvements","text":"Implement automated testing in the CI pipeline. Add monitoring and alerting for deployment failures. Improve rollback strategies in case of failed deployments.","title":"Future Improvements"},{"location":"code/code/","text":"Code Structure Overview Vinnare follows an N-Tier architecture, dividing the code into multiple layers to ensure separation of concerns, maintainability, and scalability. The system architecture is illustrated in the diagram below: Layer Responsibilities Api Layer Acts as the entry point for requests. Contains controllers to handle API endpoints. Manages middleware and dependency injection setup. Implements business logic within controllers before delegating to services. Services Layer Implements core business logic. Services interact with the database via VinnareDbContext . Controllers call services through dependency injection. Data Layer Manages database access using Entity Framework Core. Defines entities and database migrations. Shared Layer Contains globally used components such as DTOs, enums, configurations, and exceptions. Inter-layer Communication All communication between layers happens through system calls and dependency injection . Controllers can call multiple services as needed to process a request. The API layer does not interact directly with the database\u2014only services access VinnareDbContext . Code Organization and Conventions Naming Conventions Controllers: Named with Controller suffix (e.g., UserController.cs ). Services: Named with Service suffix (e.g., UserService.cs ). Tests: Follow the format {ClassName}_test.cs (e.g., UserService_test.cs ). This structured approach ensures clarity, consistency, and ease of maintenance across the project.","title":"Code Structure"},{"location":"code/code/#code-structure","text":"","title":"Code Structure"},{"location":"code/code/#overview","text":"Vinnare follows an N-Tier architecture, dividing the code into multiple layers to ensure separation of concerns, maintainability, and scalability. The system architecture is illustrated in the diagram below:","title":"Overview"},{"location":"code/code/#layer-responsibilities","text":"Api Layer Acts as the entry point for requests. Contains controllers to handle API endpoints. Manages middleware and dependency injection setup. Implements business logic within controllers before delegating to services. Services Layer Implements core business logic. Services interact with the database via VinnareDbContext . Controllers call services through dependency injection. Data Layer Manages database access using Entity Framework Core. Defines entities and database migrations. Shared Layer Contains globally used components such as DTOs, enums, configurations, and exceptions.","title":"Layer Responsibilities"},{"location":"code/code/#inter-layer-communication","text":"All communication between layers happens through system calls and dependency injection . Controllers can call multiple services as needed to process a request. The API layer does not interact directly with the database\u2014only services access VinnareDbContext .","title":"Inter-layer Communication"},{"location":"code/code/#code-organization-and-conventions","text":"Naming Conventions Controllers: Named with Controller suffix (e.g., UserController.cs ). Services: Named with Service suffix (e.g., UserService.cs ). Tests: Follow the format {ClassName}_test.cs (e.g., UserService_test.cs ). This structured approach ensures clarity, consistency, and ease of maintenance across the project.","title":"Code Organization and Conventions"},{"location":"code/db/","text":"Database Structure Overview Vinnare uses PostgreSQL as its relational database, managed through Entity Framework Core . The database consists of multiple entities representing users, products, categories, purchases, and related eCommerce operations. The database schema is visually represented in the following diagram: Entities and Relationships User Stores user data, including email and username (both unique). Users can own products, write reviews, manage wishlists, carts, and purchases. Product Represents items available for purchase. Linked to an Owner (User) . Requires admin approval before being listed. Has relationships with Categories, Reviews, Wishlists, Carts, and Jobs . Category Organizes products into different groups. Requires admin approval before being listed. Review Users can write reviews and rate products. Linked to User and Product . WishList Allows users to save products for future reference. Linked to User and Product . Cart Represents products a user intends to purchase. Linked to User and Product . Coupon Defines discount codes for promotions. Purchase Records completed transactions. Linked to User . Job Represents approval workflows for Products and Categories . Managed by Admins . Linked to User, Product, and Category . Constraints and Rules Unique Constraints User.Email and User.Username must be unique. Cascade Deletions If a user is deleted, associated products, reviews, wishlists, carts, purchases, and jobs are removed. If a product is deleted, associated reviews, wishlists, carts, and jobs are removed. Summary This structure ensures a clear relationship between users, products, and transactions while maintaining security through admin-controlled approvals. The system enforces data integrity with constraints and relationships, optimizing eCommerce operations.","title":"Database Structure"},{"location":"code/db/#database-structure","text":"","title":"Database Structure"},{"location":"code/db/#overview","text":"Vinnare uses PostgreSQL as its relational database, managed through Entity Framework Core . The database consists of multiple entities representing users, products, categories, purchases, and related eCommerce operations. The database schema is visually represented in the following diagram:","title":"Overview"},{"location":"code/db/#entities-and-relationships","text":"User Stores user data, including email and username (both unique). Users can own products, write reviews, manage wishlists, carts, and purchases. Product Represents items available for purchase. Linked to an Owner (User) . Requires admin approval before being listed. Has relationships with Categories, Reviews, Wishlists, Carts, and Jobs . Category Organizes products into different groups. Requires admin approval before being listed. Review Users can write reviews and rate products. Linked to User and Product . WishList Allows users to save products for future reference. Linked to User and Product . Cart Represents products a user intends to purchase. Linked to User and Product . Coupon Defines discount codes for promotions. Purchase Records completed transactions. Linked to User . Job Represents approval workflows for Products and Categories . Managed by Admins . Linked to User, Product, and Category .","title":"Entities and Relationships"},{"location":"code/db/#constraints-and-rules","text":"Unique Constraints User.Email and User.Username must be unique. Cascade Deletions If a user is deleted, associated products, reviews, wishlists, carts, purchases, and jobs are removed. If a product is deleted, associated reviews, wishlists, carts, and jobs are removed.","title":"Constraints and Rules"},{"location":"code/db/#summary","text":"This structure ensures a clear relationship between users, products, and transactions while maintaining security through admin-controlled approvals. The system enforces data integrity with constraints and relationships, optimizing eCommerce operations.","title":"Summary"}]}