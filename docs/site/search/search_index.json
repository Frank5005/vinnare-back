{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Vinnare eCommerce Project Documentation Overview Vinnare is an eCommerce API built using .NET, structured into multiple layers for maintainability and scalability. It follows a modular approach, separating concerns across different projects. Project Structure Api/ : Contains the API layer with controllers, DTOs, middleware, and extensions. Data/ : Manages the database context, entities, and migrations. Services/ : Implements business logic with service classes, interfaces and builders. Shared/ : Contains shared configurations, DTOs, enums, and exceptions. ConsoleAppMigration/ : A console application for managing database migrations. docs/ : Documentation files for the project using MkDocs. .github/ : CI/CD workflows for automated builds and deployments. logs/ : Contains application logs. Program.cs Overview The Program.cs file serves as the entry point of the API, configuring essential components: Service Registration Controllers Database configuration using Entity Framework Core Open Telemetry configuration Rate limiting Logging configuration Swagger for API documentation Settings used Middleware Configuration Custom middleware for error handling Custom middleware for autentication HTTPS redirection How to Run the Project To run the project, ensure you are in the root folder . Using Docker: docker build . -t vinnare -f ./Api/Dockerfile docker run vinnare Running Locally: dotnet restore dotnet build dotnet Api/bin/Debug/net8.0/Api.dll Documentation Structure The documentation is managed using MkDocs, with sections covering: - Features ( features.md ) - Setup and Execution ( how_to_run.md ) - Code Structure ( code.md ) - CI/CD Processes ( ci_cd.md ) - Technical Issues and Troubleshooting ( technical_issues.md ) - Architecture Diagrams ( diagrams.md )","title":"Vinnare eCommerce Project Documentation"},{"location":"#vinnare-ecommerce-project-documentation","text":"","title":"Vinnare eCommerce Project Documentation"},{"location":"#overview","text":"Vinnare is an eCommerce API built using .NET, structured into multiple layers for maintainability and scalability. It follows a modular approach, separating concerns across different projects.","title":"Overview"},{"location":"#project-structure","text":"Api/ : Contains the API layer with controllers, DTOs, middleware, and extensions. Data/ : Manages the database context, entities, and migrations. Services/ : Implements business logic with service classes, interfaces and builders. Shared/ : Contains shared configurations, DTOs, enums, and exceptions. ConsoleAppMigration/ : A console application for managing database migrations. docs/ : Documentation files for the project using MkDocs. .github/ : CI/CD workflows for automated builds and deployments. logs/ : Contains application logs.","title":"Project Structure"},{"location":"#programcs-overview","text":"The Program.cs file serves as the entry point of the API, configuring essential components: Service Registration Controllers Database configuration using Entity Framework Core Open Telemetry configuration Rate limiting Logging configuration Swagger for API documentation Settings used Middleware Configuration Custom middleware for error handling Custom middleware for autentication HTTPS redirection","title":"Program.cs Overview"},{"location":"#how-to-run-the-project","text":"To run the project, ensure you are in the root folder .","title":"How to Run the Project"},{"location":"#using-docker","text":"docker build . -t vinnare -f ./Api/Dockerfile docker run vinnare","title":"Using Docker:"},{"location":"#running-locally","text":"dotnet restore dotnet build dotnet Api/bin/Debug/net8.0/Api.dll","title":"Running Locally:"},{"location":"#documentation-structure","text":"The documentation is managed using MkDocs, with sections covering: - Features ( features.md ) - Setup and Execution ( how_to_run.md ) - Code Structure ( code.md ) - CI/CD Processes ( ci_cd.md ) - Technical Issues and Troubleshooting ( technical_issues.md ) - Architecture Diagrams ( diagrams.md )","title":"Documentation Structure"},{"location":"features/","text":"Features Overview Vinnare is a .NET 8-based eCommerce API providing core functionalities for managing an online marketplace. It includes user authentication, product management, shopping features, and administrative approval workflows. Core Features User Authentication & Authorization JWT-based authentication Role-based access control (Admin, Seller, Shopper) Secure password hashing with salt and pepper Product & Category Management Sellers can create and manage products Categories to organize products Admin approval required for products and categories to be listed Shopping Features Add products to cart Checkout process Wishlist functionality Reviews with comments and ratings Discounts through coupon codes Admin Job Management Approval workflow for products and categories Role management and access control Technology Stack Backend : .NET 8, Entity Framework Core Testing : Moq and xUnit Security : JWT authentication, password hashing with salt and pepper Tech features Cloud (aws) deployment of both servers and databases Automated deployment of aplication using ci-cd Monitoring using aspire dashboard over 85% code coverage In-memory caching using the write through strategy SSL certificates (autosigned) Proxy (nginx) for redireccion and serving those certificates Docker compose to handle multiple containers Integrations Initial Data Load : Fetches test data from FakeStore API for development and testing purposes.","title":"Features"},{"location":"features/#features","text":"","title":"Features"},{"location":"features/#overview","text":"Vinnare is a .NET 8-based eCommerce API providing core functionalities for managing an online marketplace. It includes user authentication, product management, shopping features, and administrative approval workflows.","title":"Overview"},{"location":"features/#core-features","text":"User Authentication & Authorization JWT-based authentication Role-based access control (Admin, Seller, Shopper) Secure password hashing with salt and pepper Product & Category Management Sellers can create and manage products Categories to organize products Admin approval required for products and categories to be listed Shopping Features Add products to cart Checkout process Wishlist functionality Reviews with comments and ratings Discounts through coupon codes Admin Job Management Approval workflow for products and categories Role management and access control","title":"Core Features"},{"location":"features/#technology-stack","text":"Backend : .NET 8, Entity Framework Core Testing : Moq and xUnit Security : JWT authentication, password hashing with salt and pepper","title":"Technology Stack"},{"location":"features/#tech-features","text":"Cloud (aws) deployment of both servers and databases Automated deployment of aplication using ci-cd Monitoring using aspire dashboard over 85% code coverage In-memory caching using the write through strategy SSL certificates (autosigned) Proxy (nginx) for redireccion and serving those certificates Docker compose to handle multiple containers","title":"Tech features"},{"location":"features/#integrations","text":"Initial Data Load : Fetches test data from FakeStore API for development and testing purposes.","title":"Integrations"},{"location":"code/architecture/","text":"Architecture Overview Vinnare follows a monolitic Architecture and a N-Tier patern, dividing the code into 3 layers to ensure separation of concerns, maintainability, and scalability. The system architecture is illustrated in the diagram below: To see how each Controller communicates to their corresponding services this are the simplified diagrams showing the flow of concerns: for. Auth, Category, Product, Review and User: for. Cart and WishList: for. Job and Purchase: Layer Responsibilities Api Layer Acts as the entry point for requests. Contains controllers to handle API endpoints. Manages middleware and dependency injection setup. Implements business logic within controllers before delegating to services. Services Layer Implements core business logic. Services interact with the database via VinnareDbContext . Controllers call services through dependency injection. Implements Builders, Builders at the contrary of services, are statefull Data Layer Manages database access using Entity Framework Core. Defines entities and database migrations. Shared Layer Contains globally used components such as DTOs, enums, configurations, and exceptions. Inter-layer Communication All communication between layers happens through system calls and dependency injection . Controllers can call multiple services as needed to process a request. The builders are statefull clasess, For this reason they have a factory to serve them. The API layer does not interact directly with the database\u2014only services access VinnareDbContext . Code Organization and Conventions Naming Conventions Controllers: Named with Controller suffix (e.g., UserController.cs ). Services: Named with Service suffix (e.g., UserService.cs ). Tests: Follow the format {ClassName}_test.cs (e.g., UserService_test.cs ). This structured approach ensures clarity, consistency, and ease of maintenance across the project.","title":"Architecture"},{"location":"code/architecture/#architecture","text":"","title":"Architecture"},{"location":"code/architecture/#overview","text":"Vinnare follows a monolitic Architecture and a N-Tier patern, dividing the code into 3 layers to ensure separation of concerns, maintainability, and scalability. The system architecture is illustrated in the diagram below: To see how each Controller communicates to their corresponding services this are the simplified diagrams showing the flow of concerns: for. Auth, Category, Product, Review and User: for. Cart and WishList: for. Job and Purchase:","title":"Overview"},{"location":"code/architecture/#layer-responsibilities","text":"Api Layer Acts as the entry point for requests. Contains controllers to handle API endpoints. Manages middleware and dependency injection setup. Implements business logic within controllers before delegating to services. Services Layer Implements core business logic. Services interact with the database via VinnareDbContext . Controllers call services through dependency injection. Implements Builders, Builders at the contrary of services, are statefull Data Layer Manages database access using Entity Framework Core. Defines entities and database migrations. Shared Layer Contains globally used components such as DTOs, enums, configurations, and exceptions.","title":"Layer Responsibilities"},{"location":"code/architecture/#inter-layer-communication","text":"All communication between layers happens through system calls and dependency injection . Controllers can call multiple services as needed to process a request. The builders are statefull clasess, For this reason they have a factory to serve them. The API layer does not interact directly with the database\u2014only services access VinnareDbContext .","title":"Inter-layer Communication"},{"location":"code/architecture/#code-organization-and-conventions","text":"Naming Conventions Controllers: Named with Controller suffix (e.g., UserController.cs ). Services: Named with Service suffix (e.g., UserService.cs ). Tests: Follow the format {ClassName}_test.cs (e.g., UserService_test.cs ). This structured approach ensures clarity, consistency, and ease of maintenance across the project.","title":"Code Organization and Conventions"},{"location":"code/ci_cd/","text":"CI/CD Pipelines Overview The CI/CD pipeline automates the process of building, testing, and deploying the application using GitHub Actions . It consists of three workflows: 1. Testing ( ci.yml ) : - Triggers on pushes to the actions branch and pull requests to main . - Runs tests. CI Workflow ( ci.yml ) : Builds a Docker image from the Api/Dockerfile . Pushes the Docker image to AWS ECR, tagging it with the commit hash. Passes the image tag to the deployment pipeline. CD Workflow ( cd.yml ) : Called by the CI pipeline after a successful build and push. Runs on an EC2 instance via SSH. Pulls the latest Docker image from ECR. Stops and removes the previous container. Deploys the new image as a running container. Secrets and Security AWS credentials and repository details are stored as GitHub secrets. The EC2 server's SSH credentials are securely stored and accessed only during deployment. Reasoning Why GitHub Actions? Cloud Advantages : No need to manage CI/CD infrastructure. Seamless Secret Management : Integrates easily with GitHub Secrets. Simplicity & Integration : Works natively with GitHub repositories. Why Two Pipelines? Separation of Concerns : CI (build, test, push) and CD (deploy) are handled separately. Better Modularity : Allows independent improvements and debugging of CI/CD stages. Secrets and Security AWS credentials and repository details are stored as GitHub secrets. The EC2 server's SSH credentials are securely stored and accessed only during deployment. Future Improvements Implement automated testing in the CI pipeline. Add monitoring and alerting for deployment failures. Improve rollback strategies in case of failed deployments.","title":"CI/CD Pipelines"},{"location":"code/ci_cd/#cicd-pipelines","text":"","title":"CI/CD Pipelines"},{"location":"code/ci_cd/#overview","text":"The CI/CD pipeline automates the process of building, testing, and deploying the application using GitHub Actions . It consists of three workflows: 1. Testing ( ci.yml ) : - Triggers on pushes to the actions branch and pull requests to main . - Runs tests. CI Workflow ( ci.yml ) : Builds a Docker image from the Api/Dockerfile . Pushes the Docker image to AWS ECR, tagging it with the commit hash. Passes the image tag to the deployment pipeline. CD Workflow ( cd.yml ) : Called by the CI pipeline after a successful build and push. Runs on an EC2 instance via SSH. Pulls the latest Docker image from ECR. Stops and removes the previous container. Deploys the new image as a running container.","title":"Overview"},{"location":"code/ci_cd/#secrets-and-security","text":"AWS credentials and repository details are stored as GitHub secrets. The EC2 server's SSH credentials are securely stored and accessed only during deployment.","title":"Secrets and Security"},{"location":"code/ci_cd/#reasoning","text":"","title":"Reasoning"},{"location":"code/ci_cd/#why-github-actions","text":"Cloud Advantages : No need to manage CI/CD infrastructure. Seamless Secret Management : Integrates easily with GitHub Secrets. Simplicity & Integration : Works natively with GitHub repositories.","title":"Why GitHub Actions?"},{"location":"code/ci_cd/#why-two-pipelines","text":"Separation of Concerns : CI (build, test, push) and CD (deploy) are handled separately. Better Modularity : Allows independent improvements and debugging of CI/CD stages.","title":"Why Two Pipelines?"},{"location":"code/ci_cd/#secrets-and-security_1","text":"AWS credentials and repository details are stored as GitHub secrets. The EC2 server's SSH credentials are securely stored and accessed only during deployment.","title":"Secrets and Security"},{"location":"code/ci_cd/#future-improvements","text":"Implement automated testing in the CI pipeline. Add monitoring and alerting for deployment failures. Improve rollback strategies in case of failed deployments.","title":"Future Improvements"},{"location":"code/db/","text":"Database Structure Overview Vinnare uses PostgreSQL as its relational database, managed through Entity Framework Core . The database consists of multiple entities representing users, products, categories, purchases, and related eCommerce operations. The database schema is visually represented in the following diagram: Entities and Relationships User Stores user details like Email and Username , both uniquely indexed. Can own products, write reviews, manage wishlists and carts, make purchases, and initiate jobs (approval requests). Product Represents an item available for sale. Belongs to a User (Owner) and a Category . Requires admin approval ( Approved defaults to false ). Linked to Reviews, Wishlists, Carts, and Jobs . Cascade deletes ensure associated data is removed if the product is deleted. Category Groups products under defined types. Requires admin approval before being listed ( Approved defaults to false ). Linked to Products and Jobs . Review Created by users to rate and review products. Linked to both a User and a Product . Cascade deletes apply when either the user or product is removed. WishList Lets users save products for future consideration. Uniquely constrained per (UserId, ProductId) . Cascade deletes apply for both related entities. Cart Represents products added by users with intent to buy. Also uniquely constrained per (UserId, ProductId) . Cascade deletes apply similarly as in WishLists. Coupon Stores discount codes. Each Code is uniquely indexed. Purchase Represents a completed transaction. Linked to a User with cascade deletion behavior. Job Used in moderation workflows for Products and Categories . Managed by Admins and linked to: User (creator), Product (optional), Category (optional). All relationships use cascade deletion for cleanup. Constraints and Rules Unique Constraints User.Email User.Username WishList (UserId, ProductId) Cart (UserId, ProductId) Coupon.Code Cascade Deletions Deleting a User removes all related Products, Reviews, WishLists, Carts, Purchases, and Jobs . Deleting a Product removes related Reviews, WishLists, Carts, and Jobs . Deleting a Category removes associated Jobs .","title":"Database Structure"},{"location":"code/db/#database-structure","text":"","title":"Database Structure"},{"location":"code/db/#overview","text":"Vinnare uses PostgreSQL as its relational database, managed through Entity Framework Core . The database consists of multiple entities representing users, products, categories, purchases, and related eCommerce operations. The database schema is visually represented in the following diagram:","title":"Overview"},{"location":"code/db/#entities-and-relationships","text":"User Stores user details like Email and Username , both uniquely indexed. Can own products, write reviews, manage wishlists and carts, make purchases, and initiate jobs (approval requests). Product Represents an item available for sale. Belongs to a User (Owner) and a Category . Requires admin approval ( Approved defaults to false ). Linked to Reviews, Wishlists, Carts, and Jobs . Cascade deletes ensure associated data is removed if the product is deleted. Category Groups products under defined types. Requires admin approval before being listed ( Approved defaults to false ). Linked to Products and Jobs . Review Created by users to rate and review products. Linked to both a User and a Product . Cascade deletes apply when either the user or product is removed. WishList Lets users save products for future consideration. Uniquely constrained per (UserId, ProductId) . Cascade deletes apply for both related entities. Cart Represents products added by users with intent to buy. Also uniquely constrained per (UserId, ProductId) . Cascade deletes apply similarly as in WishLists. Coupon Stores discount codes. Each Code is uniquely indexed. Purchase Represents a completed transaction. Linked to a User with cascade deletion behavior. Job Used in moderation workflows for Products and Categories . Managed by Admins and linked to: User (creator), Product (optional), Category (optional). All relationships use cascade deletion for cleanup.","title":"Entities and Relationships"},{"location":"code/db/#constraints-and-rules","text":"Unique Constraints User.Email User.Username WishList (UserId, ProductId) Cart (UserId, ProductId) Coupon.Code Cascade Deletions Deleting a User removes all related Products, Reviews, WishLists, Carts, Purchases, and Jobs . Deleting a Product removes related Reviews, WishLists, Carts, and Jobs . Deleting a Category removes associated Jobs .","title":"Constraints and Rules"},{"location":"code/testing/","text":"Testing Strategy Overview Vinnare follows a robust and maintainable testing strategy that prioritizes clarity , coverage , and reliability . We aim for consistent practices across all layers, from controllers to services, with a strong emphasis on isolating logic through mocking and in-memory databases. Current test coverage exceeds 85% Testing Principles Isolation Each test runs in isolation without side effects. This is achieved through: Mocking interfaces like ITokenService , IUserService , or ILogger<T> to focus only on the logic under test. In-memory databases (via TestDbContextFactory ) for integration-like service tests without external dependencies. Repeatability Tests can be run multiple times with consistent results. All state is reset per test through fresh DB context instances and mock setups. Expressive Assertions Each test clearly communicates intent through structured Arrange-Act-Assert blocks, using: Assert.IsType<> to verify response types. Assert.Equal , Assert.Null , or Assert.NotNull to validate output data. Assert.ThrowsAsync<ExceptionType> to enforce failure expectations. Controller Tests Controller-level tests validate HTTP logic and error handling using mocked services. Key patterns include: Simulated requests with DTOs to mirror real-world usage. Mocked dependencies to ensure controller logic is verified independently of service implementations. Exception validation , asserting that proper exceptions are thrown for invalid input or unauthorized access. These ensure that endpoints behave as expected for both success and failure paths. Service Tests Service logic is tested using real EF Core contexts configured with the TestDbContextFactory . This allows us to: Verify CRUD operations on in-memory data. Simulate more realistic flows (e.g., cart manipulation, product lookup). Confirm DB-side behavior like relationships and cascade deletions. Each service test focuses on real usage scenarios and data consistency. Test Utilities TestDbContextFactory public static VinnareDbContext Create() { var options = new DbContextOptionsBuilder<VinnareDbContext>() .UseInMemoryDatabase(databaseName: $\"TestDb_{Guid.NewGuid()}\") .Options; var context = new VinnareDbContext(options); context.Database.EnsureCreated(); return context; } This static utility provides clean, isolated VinnareDbContext instances backed by in-memory databases with unique names per test run. It ensures: No state leakage between tests. DB behavior remains testable without a real server. Data setup is fast and reliable. Best Practices Keep test files named consistently with the class under test (e.g., AuthController_test.cs , CartService_test.cs ). Place tests next to the logic they validate for improved maintainability. Mock only what is needed \u2014 let EF and data models behave naturally where it adds value. Avoid over-testing simple mappings or trivial getters/setters. Focus on behavior , not implementation.","title":"Testing Strategy"},{"location":"code/testing/#testing-strategy","text":"","title":"Testing Strategy"},{"location":"code/testing/#overview","text":"Vinnare follows a robust and maintainable testing strategy that prioritizes clarity , coverage , and reliability . We aim for consistent practices across all layers, from controllers to services, with a strong emphasis on isolating logic through mocking and in-memory databases. Current test coverage exceeds 85%","title":"Overview"},{"location":"code/testing/#testing-principles","text":"","title":"Testing Principles"},{"location":"code/testing/#isolation","text":"Each test runs in isolation without side effects. This is achieved through: Mocking interfaces like ITokenService , IUserService , or ILogger<T> to focus only on the logic under test. In-memory databases (via TestDbContextFactory ) for integration-like service tests without external dependencies.","title":"Isolation"},{"location":"code/testing/#repeatability","text":"Tests can be run multiple times with consistent results. All state is reset per test through fresh DB context instances and mock setups.","title":"Repeatability"},{"location":"code/testing/#expressive-assertions","text":"Each test clearly communicates intent through structured Arrange-Act-Assert blocks, using: Assert.IsType<> to verify response types. Assert.Equal , Assert.Null , or Assert.NotNull to validate output data. Assert.ThrowsAsync<ExceptionType> to enforce failure expectations.","title":"Expressive Assertions"},{"location":"code/testing/#controller-tests","text":"Controller-level tests validate HTTP logic and error handling using mocked services. Key patterns include: Simulated requests with DTOs to mirror real-world usage. Mocked dependencies to ensure controller logic is verified independently of service implementations. Exception validation , asserting that proper exceptions are thrown for invalid input or unauthorized access. These ensure that endpoints behave as expected for both success and failure paths.","title":"Controller Tests"},{"location":"code/testing/#service-tests","text":"Service logic is tested using real EF Core contexts configured with the TestDbContextFactory . This allows us to: Verify CRUD operations on in-memory data. Simulate more realistic flows (e.g., cart manipulation, product lookup). Confirm DB-side behavior like relationships and cascade deletions. Each service test focuses on real usage scenarios and data consistency.","title":"Service Tests"},{"location":"code/testing/#test-utilities","text":"","title":"Test Utilities"},{"location":"code/testing/#testdbcontextfactory","text":"public static VinnareDbContext Create() { var options = new DbContextOptionsBuilder<VinnareDbContext>() .UseInMemoryDatabase(databaseName: $\"TestDb_{Guid.NewGuid()}\") .Options; var context = new VinnareDbContext(options); context.Database.EnsureCreated(); return context; } This static utility provides clean, isolated VinnareDbContext instances backed by in-memory databases with unique names per test run. It ensures: No state leakage between tests. DB behavior remains testable without a real server. Data setup is fast and reliable.","title":"TestDbContextFactory"},{"location":"code/testing/#best-practices","text":"Keep test files named consistently with the class under test (e.g., AuthController_test.cs , CartService_test.cs ). Place tests next to the logic they validate for improved maintainability. Mock only what is needed \u2014 let EF and data models behave naturally where it adds value. Avoid over-testing simple mappings or trivial getters/setters. Focus on behavior , not implementation.","title":"Best Practices"}]}